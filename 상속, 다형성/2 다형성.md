> polymorphism (다형성)

# 상속과 다형성

1. 상속
> 공통된 기능을 물려받아 사용하고 싶은 경우
2. 다형성
> 자식클래스들이 많고 종류 또한 유동적일떄 상위 클래스로 묶어서 관리하고 싶을 경우
> 상위 클래스를 포인터형으로 사용하여 데이터형을 통일할 수 있다.


# 1. 다형성의 예시, 사용하는 이유
- [참고 사이트](https://m.blog.naver.com/PostView.nhn?blogId=tipsware&logNo=221091548997&referrerCode=0&searchKeyword=%EB%8B%A4%ED%98%95%EC%84%B1)
- [참고 사이트](https://m.blog.naver.com/tipsware/221070654506)

 ```
    Pet 클래스 : 애완동물이라는 큰 개념의 기능

        > Pet 클래스 상속
        Dog 클래스 : Pet 클래스 + Dog 만의 특별한 기능

        Cat 클래스 : Pet 클래스ㄹ + Cat 만의 특별한 기능

        class Pet
        { // Dog, cat 의 공통된 기능 };

        class Dog : public Pet
        { // Dog 의 특별한 기능 };

        class Cat : public Pet
        { // Cat 의 특별한 기능 };
```
> Pet 클래스의 파생 클래스로 Dog, Cat 이 되면 상속관계가 되어 다형성을 사용할 수 있다.

- Mouse 라는 클래스를 추가한다면?
> Pet 이라는 공통된 클래스를 상속받고 Mouse 만의 특별한 기능을 추가시켜 주면 된다.
> 기존의 Dog, Cat 이 Mouse 와 공유하는 코드는 Pet 밖에 없기 때문에 Dog, cat 클래스를 직접 수정할 필요없다.

### 1-1. 다형성을 사용해보자
- 객체를 사용하는 코드에 Dog, Cat 이라는 클래스 대신 Pet 으로 표현할 수 있다.
```
Pet *arr = new Pet[5];
arr[0] = new Dog;
arr[1] = new Cat;
arr[2] = new Cat;
arr[3] = new Dog;
arr[4] = new Mouse;
```
> Dog, Cat 으로 관리하지않고 Pet 으로만 관리가능
> 코드 간결
> 조건문 간결

> 애완동물의 종류가 늘어날때마다 new (애완동물) 코드도 증가하는데 이 부분도 다형성을 고려할 수 있다.
- [참고 사이트](https://m.blog.naver.com/tipsware/221070654506)









# 2. virtual 키워드

- 포인터를 사용해 객체를 가리킬때 부모 클래스의 자료형으로 포인터를 선언해도된다 (1-1 항목)
- 사용할 기초 클래스의 멤버 함수 **선언**에만 붙여주면 된다.

### virtaul 을 사용하는 이유 : 포인터의 자료형이 부모 클래스일때 발생할 에러
- [참고사이트](https://m.blog.naver.com/tipsware/221089473835)
```
Cat data;
Pet *p = &data;
p->Add(5);
```
- Cat 클래스의 Add 멤버 함수가 호출을 예상하지만 pet 의 Add 멤버 함수가 호출된다.
> C++ 컴파일러가 포인터와 관련된 코드를 컴파일 할떄 포인터가 선언된 자료형을 우선으로 판단한다.
> 포인터 p 는 'Pet *' 으로 선언됐기 때문에 어떤 자료형이든 상관 없이 Pet 클래스와 관련된 함수릃 호출한다.
> 자식클래스에서 부모 클래스의 함수를 오버라이딩 했을 때 발생한다.

*** 다형성이 적용된 포인터를 사용해 객체의 메서드를 호출할때 해당 함수가 부모(기초) 클래스를 오버라이딩한 함수인지 알려주어야한다.**
> 기초 클래스에 오버라이딩할 함수를 virtual 키워드로 붙여준다.



### 다형성이 적용된 경우
- 부모 객체의 함수가 아닌 자식 객체의 함수를 호출하려면
> 1. 함수가 오버라이딩 됐는지
> 2. 포인터가 가리키는 객체가 사용하는 함수의 주소가 저장된 저장된 정보 필요
> 부모 클래스의 함수에 virtaul 키워드를 적어준다.

### 오버라이딩된 모든 함수에 virtual 키워드를 넣어야하나?
- virtaul 키워드는 다형성을 사용할때 부모클래스의 함수를 자식클래스에서 오버라이딩 했다는 것을 구분지어 준다.
- 다형성이 되는 상황을 대비해 여러 정보를 저장히기 때문에 컴파일 시간이 늘어남
- 다형성을 사용하지 않는다면 굳이 virtual 키워드를 사용할 필요가 없다.

### 다형성과 destructor

- 다형성을 사용하는 경우 자식 클래스인 객체의 파괴자가 호출되지 않기 때문에 기초(부모) 클래스의 destructor 만 호출 된다.

- 파생(자식) 클래스의 destructor 도 호출되게 하기 위해서 기초 클래스의 destructor 에 virtual 키워드를 붙여준다.
> 파생 클래스의 desturctor 호출 =====> 기초 클래스의 destrcutor 호출
