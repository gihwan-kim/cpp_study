# 1) 연산자 오버로딩


```
함수 오버로딩 : 함수 시그니처(매개변수 리스트) 를 다르게하여 함사룰 작성
연산자는 이미 오버로딩 되어있음
사용자 정의 데이터형에서도 연산자가 적용되도록 오버로딩하기
```

```
operatorOP(argument-list)
```


1. 오버로딩된 연산자는 적어도 하나의 피연산자가 사용자 정의 데이터형이어야 한다.
2. 원래의 연산자의 문법 규칙을 위반하도록 설계할 수 없음
3. 연산자의 우선선위를 변경할 수 없다.
4. 연산자 기호를 새로 만들 수 없다.
5. 오버로딩할 수 없는 연산자들
```
sizeof

'.'  :  멤버 연산자
'.*' :  멤버인데 포인터접근
'::' :  사용 범위 결정 연산자
':?' :  조건 연산자
```

object_A operator obejct_B
> object_A.operatorOP(object_b);

# 2) 프렌드
- 멤버 함수처럼 클래스의 멤버에 접근할 수 있도록

1. 프렌드 함수
2. 프렌드 클래스
3. 프렌드 멤버 함수


연산자를 사용해 피연산자를 연산할때 한쪽이 객체가 아닐 경우에 유용하다.
무조건 한족만 객체여야하는건 아님 둘다 객체여도 프렌드 함수로 만들 수 있음
```
object + 1
> object.operator+(1);

1 + object
> 1.operator+(1);
> opeartor+(1, obejct);

1 은 객체가 아니기 때문에 불가능
```

### 사용

```
friend return_type function(argument-list);
```

1. 함수 원형은 클래스 선언 안에서 선언된다.
2. 멤버 함수가 아니다.
3. 멤버 연산자 '.' 를 사용하여 호출하지 않는다.
4. 멤버 함수는 아니지만 멤버 함수와 동등한 접근권한을 가진다.
5. 함수 선언에만 friend 를 붙인다.
6. 함수 정의에는 friend, 사용 범위 결정 연산자('::") 를 사용하지 않는다.