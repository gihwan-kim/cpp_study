# 객체를 사용하기 전에 객체를 초기화하기

> 데이터의 종류에 따라 초기화를 하지 않으면 알아서 초기화해주는 경우도 있고
> 초기화하지 않는 경우도 있다.

- 모든 객체를 사용하기전에 항상 초기화해주는 게 좋다.

### 대입과 초기화는 다르다.

- C++ 규칙에 의하면 객체, 객체의 데이터 멤버는 생성자의 { } 부분이 실행되기 전에 초기화 됨
    > 기본 데이터형의 경우 초기화가 되었다는 보장은 없다.
- { } 코드 블럭 안에서 '=' 기호를 사용하는 것은 대입에 해당된다.
```
ClassName::ClassName(val1, val2, val3)
{
    // 대입
    member_1 = val1;
    member_2 = val2;
    member_3 = val3;
}
```

### 멥버 초기화 리스트를 사용하면 된다.
```
ClassName::ClassName(val1, val2, val3)
    : member_1(val1), member_2(val2), memeber_3(val3)
{ }
```
- 대입을 사용한 생성자보다 효율적이다.

- 대입만 사용할 경우 대입을 사용하기 전에 해당 데이터 멤버가 객체일 경우와 같이 기본 생성자를 호출할 수도 있다.
    > 이후 대입을 통해 값을 바꿀것이기 때문에 앞의 기본 생성자 호출은 쓸모없게 된다.

- 멤버 초기화 리스트를 사용할 경우 괄호안의 값은 데이터멤버의 생성자 인자로 사용된다.

- 기본 데이터형(int, char ...) 의 경우 초기화 대입의 차이가 딱히 없지만 멤버 초기화 레스트에 넣으면 안헷갈림

- 멤버 초기화 리스트를 모든 생성자에 사용해준다면 매번 넣어주기 번거로운데 대입으로도 초기화를 할 수 있는
    멤버의 경우 따로 대입하는 함수를 사용해 코드를 줄일 수도 있다.

> 일반적인 경우에는 대입을 통한 가짜초기화 보다는 초기화 리스트를 사용한 멤버 초기화가 좋음


# 객체를 구성하는 데이터의 초기화 순서
> 모든 컴파일러에서 동일하다.


### 1. 기본 클래스는 파생 클래스보다 먼저 초기화
### 2. 클래스 데이터 멤버는 선언된 순서대로 초기화



# non-local static object (비지역 정적 객체)

> static : 프로그램이 끝날때까지 살아있음, main 함수가 종료되기 전까지

### static object 의 종류

1. 전역 객체
    > : non-local static object
2. 네임스페이스 유효범위에서 정의된 객체
    > : non-local static object
3. class 안에서 static 으로 선언된 객체
    > : non-local static object
4. 함수안에서 static 으로 선언된 객체
    > : local static object
5. 파일 유효범위 안에서 static 으로 정의된 객체
    > : non-local static object


### translation unit (= 번역 단위)
- 컴파일을 해서 하나의 오브젝트 파일을 만드는 소스코드
- 기본적으로 소스파일 하나, 해당 파일이 'include' 하는 파일까지 포함해서 하나의 번역단위

### translation unit 이 다를 경우 non-local static object 의 초기화 순서는 '정해져 있지 않다'


### non-lcoal static object 의 문제점
- 별도로 컴파일 된 소스파일이 두개 이상있고 각 소스파일에 non-local static object 가 있는 상황인 경우
- non-local static object 의 초기화 순서를 모르기 대문에 한쪽에서 다른 쪽을 사용할 경우 초기화되어있지
    않을때 에러가 발생할 수 있다.


#### 해결방법 : 비지역 정적 객체를 '지역 정적객체'로 바꿔준다.
- 함수안에서 해당 정적객체를 선언해주고 그 객체의 참조를 리턴해준다.
> 지역 정적객체의 정의를 만날 경우 초기화 되기 떄문에 초기화를 보장할 수 있게됨

> 싱글턴 패턴
> 멀티 스레드를 사용할 경우 문제될 수도 있음