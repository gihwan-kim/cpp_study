C++ 에서는 캐스팅을 조심해서 써야한다.


# 1. 캐스팅 문법


### 구형
> 표현식 부분을 T 타입으로 캐스팅한다.
> 기능은 동일함

- C 스타일 캐스트
    (T) 표현식

- 함수 방식 캐스트
    T(표현식)


### 새로운 형태의 캐스트 연산자

- 캐스팅을 사용한 부분을 발견하기도 쉽고 어떤 의도로 캐스팅을 사용했는지 판단하기 쉽다.
> 캐스팅 종류가 다양하기 때문

1. const_cast<T>(표현식)
    > 객체의 상수성 (const)을 없애는 용도
    > 상수를 비 상수로 바꾸는 것은 const_cast 가 유일하다.
2. dynamic_cast<T>(표현식)
    > 안전한 다운캐스팅을 할때 사용
    > 주어진 객체가 어떤 클래스 상속 게통에 속한 특정 타입인지 아닌지를 결정할때
3. reinterpret_cast<T>(표현식)
    > 
4. statc_cast<T>(표현식)
    > 어느 한 데이터 타입의 값을 다른 데이터 타입의 값으로 변환
    > 암시적 변환(비상수 객체->상수 객체, int->double)을 강제로 진행할 때
    > 타입 변환을 거꾸로 할때 (vod* -> 일반 포인터, 보무 클래스 포인터 -> 자식 클래스 포인터)

> 암시적 형 변환 : 알아서 형변환 되는것
> 명시적 형 변환 : 사용자가 직접 적어주는 것

큰자료형 -> 작은자료형 : 문제 발생
1. 숫자가 저장되는 방식
2. 캐스팅의 종류



# 2. Implicit type conversion (coercion)

> 연속된 비트로 저장된 변수와 변수의 타입은 컴파일러에게 비트들을 의미가 있는 값으로 해석하도록 말해준다.
> "똑같은" 숫자라도 데이터 타입이 다르면 다르게 표현할 것이다.
3, 3.0 은 다르게 저장됨

```
float f{3};
// floating point 변수를 int 3 으로 초기화를 시도함
```
- 컴파일러는 int 3 의 비트를 float 변수로 복사할수 없을 것
- 정수 값 3 을 부동 소수점 수로 변환시키고난 다음에  float 형 변수 f 에 대입된다.

### 2-1.type conversion
> 어떤 데이터 타입인 값을 다른 데이터 타입으로 변환하는 것

#### type conversion 이 발생하는 경우
1. 다른 데이터 타입인 값을 대입하거나 초기화
    ``` double d{3}; d = 6; ```
2. 함수의 파라미터로 값을 전달할떄 다른 데이터 타입을 넘겨줌
3. 함수로 부터 값을 리턴할때 다른 데이터 타입
4. 연산자를 사용할때 서로 다른 데이터 타입을 사용

> 위 경우에서 c++ 는 한 데이터타입을 다른 데이터 타입으로 변환한다


#### type conversion 종류
1. implicit : 컴파일러가 자동으로 수행
2. explicit : 개발자가 캐스팅 연산자를 사용해서 직접적으로 변환

### 2-2. 암시적 형변황이 수행되는 경우
- 한 데이터타입이 예상되고 다른 데이터 타입이 제공될 경우
- 컴파일러가 두 데이터 타입 사이에서 어떻게 변환시켜야할지 아는 경우
- 모를 경우 컴파일 실패

### Numeric promotion ( 확대변환 )
- 작은 데이터 타입에서 큰 데이터 타입으로 변환
- 안전하다, 데이터 손실 x

### Numeric conversion 
- 큰 데이터 타입에서 비슷한 작은 데이터 타입으로 변환
- 너무 작은 데이터로 변환할 경우 데이터 손실 가능성이 있다.



# 3. Explicit type conversion (casting), static_cast

- 어느 한 데이터 타입을 비슷한 큰 데이터 타입으로 바꾸고 싶을떄 암시적 형 변환은 괜찮다.

- 예시 1
    ``` float f = 10 / 4; ```
    > 10, 4 는 둘다 정수이기 때문에 형변환이 진행되지 않고 10 / 4 의 결과는 2 가 되고
    > 암시적 변환이 적용되고 난 다음 2.0 이되어 f 에 할당된다.
- 예시 2
    ```
    int i1 {10};
    int i2 {4};
    float f(i1 / i2); // list 초기화 ( '{}' ) 는 안됨 direct 초기화 ( '()' ) 는 사용가능
    ```
    > f 또한 2 로 저장될 것임

> 정수로 나눠지는게(예시1,2) 아닌 부동 소수점수로 나누기를 하고 싶은 경우 'type casting operator' 를 사용해야한다.
> 컴파일러에게 explicitt type conversion 을 하라고 말해줌




### static_cast
- 변수를 다른 타입으로 변환
- 입력으로 값 한 개를 받음
- '<>' 기호로 지정된 타입의 변환된 값을 리턴
- 기본 타입을 다른 타입으로 변환하는 가장 좋은 방법

- compile-time 에 타입을 확인한다.

> 앞에서 암시적으로 큰 데이터 형에서 작은 데이터형으로 변환될때 데이터 손실이 발생한다고 컴파일러가 경고했었다.
> static_cast 를 사용할 경우 형변환을 하기 때문에 따로 경고를 하지 않는다.


# 자식 클래스 에서 부모 클래스를 캐스팅해서 함수를 사용하지 말 것
- 가상 함수를 파생 클래스에서 오버라이딩해서 구현할때 부모 클래스의 함수를 호출해서 자식 클래스의 내용을 조금 변경해야하는 경우 부모 클래스의 함수를 호출해야한다.
- 이떄 캐스팅을 사용해서 현재 객체 (this) 를 부모 클래스 타입으로 바꿔서 멤버함수를 호출하면 안된다.
- 현재 객체를 캐스팅한것 처럼 보이겠지만
- 캐스팅을 할 경우 타입 변환이 된 새로운 값이 나오기 때문에 현재 객체가 아니다.

    ```
    class Window {
    public:
        virtual void onResize() { ... }
    }

    class SpecialWindow: public Window {
    public:
        virtual void onResize() {
            static_cast<Window>(*this).onResize(); 
            // Window::onResize() 가 호출됨
            // 캐스팅이 발생하면서 (*this) 의 부모 클래스에 대한 '복사본'이 생성된다!!
            // 현재 객체(*this) 에서 호출되는게 아니라 임시 객체(='복사본')에서 호출된 것!!

            Window::onResize();
            // *this 에서 onResize() 를 호출하는 것으로 바꾼다.
        }
    }
    ```
> 캐스팅을 사용해서 그럴듯 하게 구현한것 같지만 아닌경우도 있다.

[[[[[[[[[[[ 2/1 ]]]]]]]]]]]




# reinterpret_cast
https://docs.oracle.com/cd/E19205-01/819-5267/bkahk/index.html

```reinterpret_cast < new_type > ( expression )	```
> new_type 값을 리턴한다.
static_cast 와 비슷하게 reinterpret_cast 표현식은 CPU 명령으로 컴파일하지 않는다.
컴파일시에 컴파일러가 new_type 형식을 가진것처럼 expression 을 처리하도록한다.

1. 정수 표현식, enumeration, pointer, 멤버에대한 포인터는 자시 자신인 타입으로 변환 가능 (c++11)
    > 결과 값은 expression 값과 동일하다.

2. 정수 또는 enum 타입은 포인터 형으로 변환될 수 있다.
    > 충분한 크기의 정수로 포인터가 변환되었다가 다시 통일한 포인터 형으로 돌아왔을때 원래 값을 보장한다.

### expression 값의 해석을 바꿀 수 있다.
1. 포인터와 정수 타입간의 변환
2. 관련 없는 포인터 타입간의 변환
3. 포인터와 멤버 타입간의 변환
4. 포인터와 함수 타입간의 변환

- reinterpre_cast 의 사용은 undefrinded 또는 implementation-dependent 결과가 발생할 수 있다.

### 결과를 예상할 수 있는 변환
1. (데이터 객체를 가리키는 포인터 , 함수(멤버함수 아님)를 가리키는 포인터) -> 충분히 큰 정수 타입
    > 다시 원래 타입으로 변환되도 원래 포인터 값이 유지된다.

2. 함수를 가리키는 포인터 -> 다른 함수를 가리키는 포인터
    > 다시 원래 타입으로 변환되도 원래 포인터 값이 유지된다.

3. 객체를 가리키는 포인터 -> 다른 객체 타입을 가리키는 포인터

4. 

4. 어떤 티입인 널 포인터-> 다른 타입인 널 포인터
    > 널 포인터를 유지
    > 모든 경우에 적용됨
5. const 를 떼어내기위해 사용할 수 없음 const_cast 를 사용할 것

6. 서로 다른 클래스이지만 계층구조가 같은 클래스를 가리키는 포인터간의 변환에는 사용할 수 없다.
    > static_cast, dynamic_cast 를 사용




# dynamic_cast

```dynamic_cast < new-type > ( expression )```
- 상속 계층에 따라 포인터 및 참조를 변환한다. 
- 형변환이 셩공적일 경우 dynamic_cast 는 new-type 의 값을 리턴한다.

- 형변환 실패, new_type 이 포인터인 경우 new_type 인 null 포인터를 리턴한다.
- 형변환 실패, new_type 이 참조인 경우 exception, std::bad_cast 

### dynamic_cast 를 사용하는 경우

파생 클래스 객체임이 분명한 변수에서 파생 클래스의 함수를 호출하고 싶은데
해당 객체에 접근하는 방법이 기본 클래스의 포인터(또는 참조) 밖에 없는 경우

### 다른 방법
1. 파생 클래스 객체에 대한 포인터를 컨테이너에 담아서 사용
2. 파생클래스에서 사용하는함수를 가상함수(함수 내용을 구현하지 않은채로)로 기본 클래스에 넣어주기

### 피해야하는 방법

- 다중 if 문을 사용해서 여러 파생클래스에 대한 dynamic_cast 를 사용하는 경우

> 파생 클래스가 변경되면 if 문 코드를 수정해야하기 대문에 유지보수에도 좋지않고 속도도 느리다.

### 잘 작성된 C++ 코드는 캐스팅을 거의 쓰지 않는다.
