> 동적으로 할당한 메모리를 관리할 때
> 메모리, 동적으로 할당한 모든 리소스를 가리킨다.

1. 스마트 포인터가 스코프를 벗어나거나 리셋되면 할당된 리소스가 자동으로 해제된다.

2. 함수 스코프 안에서 동적으로 할당된 리소스를 관리하는데 사용

3. 클래스의 데이터 멤버로 사용

4. 동적으로 할당된 리소스의 소유권을 함수싀 인자로 넘겨줄때 사용


# 스마트 포인터 활용

1. **템플릿**을 이용한 스마트 포인터
- 모든 포인터 타입에 대해 안전한 스마트 포인터 클래스 사용 가능

2. **연산자 오버로딩** 을 통해 인터페이스 제공
- 스마트 포인터 객체에 대한 인터페이스를 제공
- 일반 포인터를 사용하는 것처럼
Ex.
 *, -> 연산자 오버로딩



 # 포인터를 관리하는 과정에서의 문제

 1. 스코프를 벗어날 때 헤제를 하지 않는 경우


 2. aliasing : 앨리어싱
 - 포인터의 복사본을 여러 객체나 코드에서 가지고 있을

 - 리소스를 마지막으로 사용한 지점에서 메모리를 해제해야하는데 정확하게 어디인지 구분이안되는 상황



 # std 스마트 포인터 종류

1. **std::unique_ptr** : 고유(단독) 소유권 방식
- 리소스에 대한 단독 소유권
- 스마트 포인터가 스코프를 벗어나거나 리셋되면 참조하던 리소스를 해제

2. **std::shared_ptr** : 공유 소유권 방식 (레퍼런스 카운팅)
- 리소스의 소유자를 추적

- 스마트 포인터를 복사해 스마트 포인터 인스턴스를 생성한다.
- 리소스를 가리키는 인스턴스가 생성되면 레퍼런스 카운트가 증가
- 스마트 포인터 인스턴스가 스코프를 벗어나거나 리셋되면 카운트 감소
- 카운트가 0 이 되면 리소스를 사용하는 곳이 없기 때문에 해제

> 리소스를 공유할 때





# std::unique_ptr

- delete 를 직접 호출하지 않고 unique_ptr 인스턴스가 스코프를 벗어나면 소멸자가 호출될때 리소스 해제됨

1. 생성

> make_unique 사용
```
make_uniuqe<Type>(parameter);
```
> unique_ptr 직접 생성
```
unique_ptr<Type> ptr_name (new Type());
```


2. 사용

> *, -> 로 일반 포인터처럼 참조

get() : 내부 포인터에 직접 접근
reset() : 내부 포인터 해제, 다른 포인터로 변경할 수도 있음
relase() : 내부 포인터의 관계 끊기, 소유권을 잃기 때문에 직접 해제해줘야함



# std::shared_ptr

- make_shared 로 생성



> 둘다 생성할때 커스텀으로 할당 및 해제를 변경할 수 있음
