# 1) 연산자 오버로딩


```
함수 오버로딩 : 함수 시그니처(매개변수 리스트) 를 다르게하여 함수를 작성
연산자는 이미 오버로딩 되어있음
사용자 정의 데이터형에서도 연산자가 적용되도록 오버로딩하기
```

```
operatorOP(argument-list)
```

1. 오버로딩된 연산자는 적어도 하나의 피연산자가 사용자 정의 데이터형이어야 한다.
2. 원래의 연산자의 문법 규칙을 위반하도록 설계할 수 없음
3. 연산자의 우선선위를 변경할 수 없다.
4. 연산자 기호를 새로 만들 수 없다.
5. 오버로딩할 수 없는 연산자들
```
sizeof

'.'  :  멤버 연산자
'.*' :  멤버인데 포인터접근
'::' :  사용 범위 결정 연산자
':?' :  조건 연산자
```

object_A operator obejct_B
> object_A.operatorOP(object_b);

# 2) 프렌드
- 멤버 함수처럼 클래스의 멤버에 접근할 수 있도록

1. 프렌드 함수
2. 프렌드 클래스
3. 프렌드 멤버 함수


연산자를 사용해 피연산자를 연산할때 한쪽이 객체가 아닐 경우에 유용하다.
무조건 한족만 객체여야하는건 아님 둘다 객체여도 프렌드 함수로 만들 수 있음
```
object + 1
> object.operator+(1);

1 + object
> 1.operator+(1);
> opeartor+(1, obejct);

1 은 객체가 아니기 때문에 불가능
```

### 사용

```
friend return_type function(argument-list);
```

1. **함수 원형은 클래스 선언 안에서 선언된다.**
2. **멤버 함수가 아니다.**
3. 멤버 연산자 '.' 를 사용하여 호출하지 않는다.
4. 멤버 함수는 아니지만 멤버 함수와 **동등한 접근권한**을 가진다.
5. 함수 선언에만 friend 를 붙인다.
6. 함수 정의에는 friend, 사용 범위 결정 연산자('::") 를 사용하지 않는다.




# 클래스에서 상수 사용

멤버 변수로 const 를 사용할 수 없다.
클래스를 구성할때 메모리가 생성되지 않는다.
객체가 되어야만 메모리를 할당 받기 때문에 const 를 사용할 수 없다.

1. enum 사용

2. static const 멤버 변수
> 객체 안에 생성되는 것이 아닌 다른 정적 변수들과 함께 저장됨



# 초기화 부분
**[초기화/object initialization.md 참고]**




# 객체 생성

1.